<!DOCTYPE html>
<html>
<head>
    <title>Clash Royale Pathfinding - Dijkstra</title>
</head>
<body>
    <h1>Tablero Clash Royale - Dijkstra (Camino más corto garantizado)</h1>
    <button id="limpiar">Limpiar Selección</button>
    <canvas id="tablero" width="640" height="1152"></canvas>

    <script>
        const canvas = document.getElementById('tablero');
        const ctx = canvas.getContext('2d');
        const btnLimpiar = document.getElementById('limpiar');
        
        // Configuración del tablero
        const FILAS = 32;
        const COLUMNAS = 18;
        const ANCHO_CASILLA = canvas.width / COLUMNAS;
        const ALTO_CASILLA = canvas.height / FILAS;
        
        // Estado del juego
        let puntoInicio = null;
        let puntoFin = null;
        let camino = [];
        
        // Crear grilla de casillas
        const tablero = [];
        for (let i = 0; i < FILAS; i++) {
            tablero[i] = [];
            for (let j = 0; j < COLUMNAS; j++) {
                // El río más angosto: solo filas 15, 16 (2 casillas de altura)
                const esRio = i >= 15 && i <= 16;
                // Los puentes más separados: columnas 2-4 y 13-15 (3 casillas de ancho cada uno)
                const esPuente = esRio && ((j >= 2 && j <= 4) || (j >= 13 && j <= 15));
                
                // Torres del jugador superior (filas 0-31, torres en la parte superior)
                // Torre principal superior: 4x4, centrada con 1 casilla de margen desde arriba
                const torrePrincipalSup = i >= 1 && i <= 4 && j >= 7 && j <= 10;
                
                // Torres secundarias superiores: 3x3, más atrás (más lejos del río)
                const torreIzqSup = i >= 5 && i <= 7 && j >= 2 && j <= 4;
                const torreDecSup = i >= 5 && i <= 7 && j >= 13 && j <= 15;
                
                // Torres del jugador inferior (parte inferior del tablero)
                // Torre principal inferior: 4x4, centrada con 1 casilla de margen desde abajo
                const torrePrincipalInf = i >= 27 && i <= 30 && j >= 7 && j <= 10;
                
                // Torres secundarias inferiores: 3x3, más atrás (más lejos del río)
                const torreIzqInf = i >= 24 && i <= 26 && j >= 2 && j <= 4;
                const torreDecInf = i >= 24 && i <= 26 && j >= 13 && j <= 15;
                
                const esTorre = torrePrincipalSup || torreIzqSup || torreDecSup || 
                               torrePrincipalInf || torreIzqInf || torreDecInf;
                
                let tipoTorre = null;
                if (torrePrincipalSup) tipoTorre = 'principal_sup';
                else if (torreIzqSup) tipoTorre = 'izq_sup';
                else if (torreDecSup) tipoTorre = 'der_sup';
                else if (torrePrincipalInf) tipoTorre = 'principal_inf';
                else if (torreIzqInf) tipoTorre = 'izq_inf';
                else if (torreDecInf) tipoTorre = 'der_inf';
                
                tablero[i][j] = {
                    x: j * ANCHO_CASILLA + ANCHO_CASILLA / 2,
                    y: i * ALTO_CASILLA + ALTO_CASILLA / 2,
                    fila: i,
                    columna: j,
                    transitable: !esRio || (esPuente && !esTorre),
                    esTorre: esTorre,
                    tipoTorre: tipoTorre,
                    esRio: esRio && !esPuente
                };
                
                // Las torres bloquean el paso incluso si están sobre césped
                if (esTorre) {
                    tablero[i][j].transitable = false;
                }
            }
        }
        
        // Algoritmo A*
        function encontrarCamino(inicio, fin) {
            // Limpiar valores anteriores
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    const nodo = tablero[i][j];
                    nodo.g = Infinity;
                    nodo.h = 0;
                    nodo.f = Infinity;
                    nodo.padre = null;
                }
            }
            
            const abiertos = [];
            const cerrados = new Set();
            
            // Inicializar nodo de inicio
            inicio.g = 0;
            inicio.h = heuristica(inicio, fin);
            inicio.f = inicio.g + inicio.h;
            abiertos.push(inicio);
            
            while (abiertos.length > 0) {
                // Encontrar nodo con menor f en la lista abierta
                let actual = abiertos[0];
                let indiceActual = 0;
                
                for (let i = 1; i < abiertos.length; i++) {
                    if (abiertos[i].f < actual.f) {
                        actual = abiertos[i];
                        indiceActual = i;
                    }
                }
                
                // Mover de abiertos a cerrados
                abiertos.splice(indiceActual, 1);
                cerrados.add(actual);
                
                // ¿Llegamos al objetivo?
                if (actual === fin) {
                    return reconstruirCamino(actual);
                }
                
                // Explorar vecinos
                const vecinos = obtenerVecinos(actual);
                for (const vecino of vecinos) {
                    if (!vecino.transitable || cerrados.has(vecino)) {
                        continue;
                    }
                    
                    // Calcular costo g tentativo
                    const esDiagonal = Math.abs(vecino.fila - actual.fila) === 1 && 
                                     Math.abs(vecino.columna - actual.columna) === 1;
                    const costo = esDiagonal ? Math.sqrt(2) : 1;
                    const gTentativo = actual.g + costo;
                    
                    // ¿Es un camino mejor?
                    if (gTentativo < vecino.g) {
                        vecino.padre = actual;
                        vecino.g = gTentativo;
                        vecino.h = heuristica(vecino, fin);
                        vecino.f = vecino.g + vecino.h;
                        
                        // Agregar a abiertos si no está
                        if (!abiertos.includes(vecino)) {
                            abiertos.push(vecino);
                        }
                    }
                }
            }
            
            return []; // No hay camino
        }
        
        // Heurística: distancia Manhattan
        function heuristica(nodo, objetivo) {
            return Math.abs(nodo.fila - objetivo.fila) + Math.abs(nodo.columna - objetivo.columna);
        }
        
        // Reconstruir camino siguiendo los padres
        function reconstruirCamino(nodoFinal) {
            const camino = [];
            let actual = nodoFinal;
            
            while (actual !== null) {
                camino.unshift(actual);
                actual = actual.padre;
            }
            
            return camino;
        }
        
        function obtenerVecinos(casilla) {
            const vecinos = [];
            const direcciones = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            for (const [df, dc] of direcciones) {
                const nf = casilla.fila + df;
                const nc = casilla.columna + dc;
                
                if (nf >= 0 && nf < FILAS && nc >= 0 && nc < COLUMNAS) {
                    vecinos.push(tablero[nf][nc]);
                }
            }
            
            return vecinos;
        }
        
        function dibujar() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar casillas
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    const casilla = tablero[i][j];
                    const x = j * ANCHO_CASILLA;
                    const y = i * ALTO_CASILLA;
                    
                    // Color de fondo
                    if (casilla.esTorre) {
                        // Torres según su tipo
                        if (casilla.tipoTorre.includes('principal')) {
                            ctx.fillStyle = '#9c27b0'; // Morado para torres principales (Rey/Reina)
                        } else {
                            ctx.fillStyle = '#ff9800'; // Naranja para torres secundarias
                        }
                    } else if (casilla.esRio) {
                        ctx.fillStyle = '#2196f3'; // Azul para río
                    } else if (casilla === puntoInicio) {
                        ctx.fillStyle = '#4caf50'; // Verde para inicio
                    } else if (casilla === puntoFin) {
                        ctx.fillStyle = '#f44336'; // Rojo para fin
                    } else {
                        ctx.fillStyle = '#8bc34a'; // Verde claro para césped
                    }
                    
                    ctx.fillRect(x, y, ANCHO_CASILLA, ALTO_CASILLA);
                    
                    // Borde de casilla
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, ANCHO_CASILLA, ALTO_CASILLA);
                }
            }
            
            // Dibujar grafo (conexiones transparentes)
            ctx.strokeStyle = 'rgba(128, 128, 128, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    const casilla = tablero[i][j];
                    if (!casilla.transitable) continue;
                    
                    const vecinos = obtenerVecinos(casilla);
                    for (const vecino of vecinos) {
                        if (!vecino.transitable) continue;
                        
                        ctx.beginPath();
                        ctx.moveTo(casilla.x, casilla.y);
                        ctx.lineTo(vecino.x, vecino.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Dibujar camino
            if (camino.length > 1) {
                ctx.strokeStyle = '#ff5722';
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(camino[0].x, camino[0].y);
                for (let i = 1; i < camino.length; i++) {
                    ctx.lineTo(camino[i].x, camino[i].y);
                }
                ctx.stroke();
            }
            
            // Dibujar centros de casillas transitables
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    const casilla = tablero[i][j];
                    if (casilla.transitable) {
                        ctx.fillStyle = '#d32f2f';
                        ctx.beginPath();
                        ctx.arc(casilla.x, casilla.y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                }
            }
            
            // Dibujar símbolos en las torres
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let i = 0; i < FILAS; i++) {
                for (let j = 0; j < COLUMNAS; j++) {
                    const casilla = tablero[i][j];
                    if (casilla.esTorre) {
                        let simbolo = '';
                        if (casilla.tipoTorre === 'principal_sup') simbolo = '♔'; // Rey superior
                        else if (casilla.tipoTorre === 'principal_inf') simbolo = '♚'; // Rey inferior
                        else if (casilla.tipoTorre.includes('sup')) simbolo = '♖'; // Torre superior
                        else if (casilla.tipoTorre.includes('inf')) simbolo = '♜'; // Torre inferior
                        
                        // Solo dibujar en el centro de cada torre
                        if ((casilla.tipoTorre.includes('principal') && casilla.fila === Math.floor((1+4)/2) + 1 && casilla.columna === Math.floor((7+10)/2)) ||
                            (casilla.tipoTorre === 'izq_sup' && casilla.fila === 6 && casilla.columna === 3) ||
                            (casilla.tipoTorre === 'der_sup' && casilla.fila === 6 && casilla.columna === 14) ||
                            (casilla.tipoTorre === 'principal_inf' && casilla.fila === Math.floor((27+30)/2) && casilla.columna === Math.floor((7+10)/2)) ||
                            (casilla.tipoTorre === 'izq_inf' && casilla.fila === 25 && casilla.columna === 3) ||
                            (casilla.tipoTorre === 'der_inf' && casilla.fila === 25 && casilla.columna === 14)) {
                            
                            ctx.font = 'bold 20px Arial';
                            ctx.fillText(simbolo, casilla.x, casilla.y);
                        }
                    }
                }
            }
            
            // Mostrar información del camino
            if (camino.length > 0) {
                ctx.fillStyle = '#000';
                ctx.font = '16px Arial';
                ctx.fillText(`Camino encontrado: ${camino.length} pasos`, 10, 25);
                
                // Calcular distancia real
                let distanciaTotal = 0;
                for (let i = 1; i < camino.length; i++) {
                    const dx = camino[i].columna - camino[i-1].columna;
                    const dy = camino[i].fila - camino[i-1].fila;
                    const esDiagonal = Math.abs(dx) === 1 && Math.abs(dy) === 1;
                    distanciaTotal += esDiagonal ? Math.sqrt(2) : 1;
                }
                ctx.fillText(`Distancia: ${distanciaTotal.toFixed(2)} unidades`, 10, 45);
            }
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const columna = Math.floor(x / ANCHO_CASILLA);
            const fila = Math.floor(y / ALTO_CASILLA);
            
            if (fila >= 0 && fila < FILAS && columna >= 0 && columna < COLUMNAS) {
                const casilla = tablero[fila][columna];
                
                if (!casilla.transitable) return;
                
                if (!puntoInicio) {
                    puntoInicio = casilla;
                } else if (!puntoFin && casilla !== puntoInicio) {
                    puntoFin = casilla;
                    camino = encontrarCamino(puntoInicio, puntoFin);
                }
                
                dibujar();
            }
        });
        
        btnLimpiar.addEventListener('click', () => {
            puntoInicio = null;
            puntoFin = null;
            camino = [];
            dibujar();
        });
        
        // Dibujo inicial
        dibujar();
    </script>
</body>
</html>